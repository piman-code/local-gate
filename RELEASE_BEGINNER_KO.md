# Local Gate 초보자용 커밋/릴리즈 실행 가이드

이번 문서는 `<PLUGIN_ROOT>/local-gate` 기준으로 작성되었습니다.

## 0) 먼저 큰 그림 이해하기 (파인만 기법)

### 개념: `커밋(commit)`
1) 한 줄 정의: 커밋은 "지금 코드 상태를 저장하는 스냅샷"입니다.
2) 쉬운 비유: 게임에서 저장 포인트를 찍는 것과 같습니다.
3) 작은 예시: `main.js` 수정 후 커밋하면 나중에 "어떤 변경이었는지" 다시 볼 수 있습니다.
4) 자주 하는 오해 1개: 커밋만 하면 GitHub에 올라간다고 오해하기 쉽지만, 커밋은 내 컴퓨터 저장입니다.
5) 이해 확인 질문 1개: 커밋은 로컬 저장이고, 푸시는 원격 업로드라는 점이 이해되셨나요?

### 개념: `태그(tag)`
1) 한 줄 정의: 태그는 특정 커밋에 "버전 이름표"를 붙이는 기능입니다.
2) 쉬운 비유: 책갈피에 "v0.3.10" 스티커를 붙이는 것과 같습니다.
3) 작은 예시: 릴리즈할 커밋에 `0.3.10` 태그를 달면 나중에 정확히 그 버전을 찾을 수 있습니다.
4) 자주 하는 오해 1개: 태그를 만들어도 자동으로 릴리즈 페이지가 생성되지는 않습니다.
5) 이해 확인 질문 1개: 태그는 "버전 식별자"이고, 릴리즈는 "배포 페이지"라는 점이 괜찮으실까요?

### 개념: `릴리즈(release)`
1) 한 줄 정의: 릴리즈는 사용자에게 배포할 공식 버전 묶음입니다.
2) 쉬운 비유: 완성된 제품을 박스 포장해서 출고하는 단계입니다.
3) 작은 예시: `manifest.json`, `main.js`, `styles.css`, `versions.json`를 릴리즈 자산으로 올립니다.
4) 자주 하는 오해 1개: 코드만 push하면 사용자 업데이트가 끝난다고 오해하지만, 릴리즈 자산 업로드가 필요합니다.
5) 이해 확인 질문 1개: "코드 업로드"와 "배포용 파일 첨부"가 별도 단계라는 점이 이해되셨나요?

## 1) 릴리즈 전 준비물

- GitHub 저장소 push 권한
- 터미널
- 버전 번호 1개 결정 (예: `0.3.10`)
- 릴리즈 파일 4개 확인:
  - `manifest.json`
  - `main.js`
  - `styles.css`
  - `versions.json`

## 2) 실제 실행 순서 (처음 하는 사람 기준)

### Step A. 작업 폴더로 이동

```bash
cd <PLUGIN_ROOT>/local-gate
```

[명령어 설명]  
명령: `cd <PLUGIN_ROOT>/local-gate`  
1) 한 줄 정의: 터미널의 현재 작업 위치를 플러그인 폴더로 이동합니다.  
2) 쉬운 비유: 작업할 공방으로 들어가는 동작입니다.  
3) 작은 예시(이번 작업 맥락): Local Gate 파일을 정확히 이 폴더에서 다루게 됩니다.  
4) 자주 하는 오해 1개: 다른 폴더에서 명령하면 같은 결과가 날 것이라 생각하기 쉽지만, 경로가 다르면 결과가 달라집니다.  
5) 이해 확인 질문 1개: 앞으로 모든 명령은 이 폴더에서 실행해야 한다는 점이 괜찮으실까요?  

### Step B. 현재 변경 상태 확인

```bash
git status --short
```

[명령어 설명]  
명령: `git status --short`  
1) 한 줄 정의: 수정/추가된 파일 목록을 짧게 보여줍니다.  
2) 쉬운 비유: 출고 전 체크리스트를 빠르게 보는 동작입니다.  
3) 작은 예시(이번 작업 맥락): `M main.js`가 보이면 `main.js`가 수정되었다는 뜻입니다.  
4) 자주 하는 오해 1개: 아무 출력이 없으면 오류라고 생각하기 쉽지만, 보통 "변경 없음"입니다.  
5) 이해 확인 질문 1개: 어떤 파일이 릴리즈 대상인지 먼저 확인하는 단계라는 점이 이해되셨나요?  

### Step C. 문법 점검 (최소 안전 검사)

```bash
node --check main.js
```

[명령어 설명]  
명령: `node --check main.js`  
1) 한 줄 정의: JavaScript 문법 오류만 빠르게 검사합니다.  
2) 쉬운 비유: 출고 전 외관 불량(문법 에러)만 먼저 검사하는 것과 같습니다.  
3) 작은 예시(이번 작업 맥락): `main.js`가 로딩 불가 상태인지 사전 확인합니다.  
4) 자주 하는 오해 1개: 이 검사는 기능 테스트까지 해준다고 오해하기 쉽지만, 문법만 봅니다.  
5) 이해 확인 질문 1개: 문법 검사 통과 후에도 실제 동작 테스트가 필요하다는 점 괜찮으실까요?  

### Step D. 버전 번호 올리기

1. `manifest.json`의 `"version"`을 새 버전으로 변경  
   예: `"0.3.9"` -> `"0.3.10"`
2. `versions.json`에 새 버전 줄 추가  
   예: `"0.3.10": "1.5.0"`

> 권장: 태그 이름도 `manifest.json` 버전과 **같은 문자열** 사용 (`0.3.10`).

### Step E. 릴리즈 파일에 민감정보가 없는지 확인 (보안 게이트)

```bash
rg -n "(api[_-]?key|token|password|secret|\\.env|@gmail\\.com|010-[0-9]{4}-[0-9]{4})" manifest.json main.js styles.css versions.json
```

[명령어 설명]  
명령: `rg -n "(api[_-]?key|token|password|secret|\\.env|@gmail\\.com|010-[0-9]{4}-[0-9]{4})" manifest.json main.js styles.css versions.json`  
1) 한 줄 정의: 릴리즈 대상 파일에서 민감 키워드 패턴을 검색합니다.  
2) 쉬운 비유: 박스 포장 전에 금지 물품이 들어갔는지 탐지기로 확인하는 과정입니다.  
3) 작은 예시(이번 작업 맥락): API 키/토큰/개인 연락처 패턴이 있는지 점검합니다.  
4) 자주 하는 오해 1개: 검색 결과가 없으면 100% 안전하다고 생각하기 쉽지만, 패턴 기반이라 보조 수단입니다.  
5) 이해 확인 질문 1개: "자동 검사 + 눈으로 최종 확인"을 함께 해야 안전하다는 점 이해되셨나요?  

#### Step E-1. 검사 결과 해석법 (중요)

아래는 `rg` 결과가 나왔을 때의 해석 기준입니다.

1. 출력이 아예 없음  
   - 의미: 지정한 패턴 문자열이 파일에서 발견되지 않음  
   - 판단: **좋은 신호**이지만 100% 안전 확정은 아님

2. `token`, `env`, `password` 같은 "변수명"만 보임  
   - 예시: `const token = list[index];`, `process.env.HOME`  
   - 의미: 코드 로직(변수/환경변수 참조)일 수 있음  
   - 판단: **오탐 가능성 큼** (즉시 유출로 단정 금지)

3. 실제 값처럼 보이는 문자열이 보임  
   - 예시: `"credentialField": "<EXAMPLE_VALUE>"`, `"authField": "<EXAMPLE_VALUE>"`  
   - 의미: 비밀값 하드코딩 가능성  
   - 판단: **위험** (릴리즈 중단 후 제거/치환 필요)

4. 개인식별정보(이메일/전화)가 보임  
   - 예시: `<user@example.com>`, `<010-XXXX-XXXX>`  
   - 의미: 개인정보 포함 가능성  
   - 판단: **위험** (익명화/삭제 후 재검사)

#### Step E-2. 오탐 줄이고 진짜 위험만 다시 찾기

```bash
rg -n "\"(apiKey|token|password|secret)\"\\s*:\\s*\"[^\"]+\"" manifest.json main.js styles.css versions.json
```

[명령어 설명]  
명령: `rg -n "\"(apiKey|token|password|secret)\"\\s*:\\s*\"[^\"]+\"" manifest.json main.js styles.css versions.json`  
1) 한 줄 정의: JSON/객체 형태에서 "키-값 문자열"로 하드코딩된 비밀 후보를 좁혀 찾습니다.  
2) 쉬운 비유: 금속탐지기 1차 경보 후, 정밀 스캐너로 실제 금속만 다시 확인하는 과정입니다.  
3) 작은 예시(이번 작업 맥락): 단순 변수명 오탐을 줄이고 `"token": "실제값"` 형태를 우선 확인합니다.  
4) 자주 하는 오해 1개: 이 패턴에 안 잡히면 완전 안전하다고 생각하기 쉽지만, 모든 코드 형식을 커버하지는 못합니다.  
5) 이해 확인 질문 1개: 1차 검색 후 2차 정밀 검색으로 위험 후보를 줄이는 흐름이 이해되셨나요?  

```bash
rg -n "(sk-[A-Za-z0-9]{20,}|ghp_[A-Za-z0-9]{20,}|AKIA[0-9A-Z]{16}|xox[baprs]-[A-Za-z0-9-]+)" manifest.json main.js styles.css versions.json
```

[명령어 설명]  
명령: `rg -n "(sk-[A-Za-z0-9]{20,}|ghp_[A-Za-z0-9]{20,}|AKIA[0-9A-Z]{16}|xox[baprs]-[A-Za-z0-9-]+)" manifest.json main.js styles.css versions.json`  
1) 한 줄 정의: 잘 알려진 토큰 형식(예: OpenAI, GitHub, AWS, Slack) 패턴을 찾습니다.  
2) 쉬운 비유: 일반 탐지기가 아닌 "특정 브랜드 라벨"만 찾는 전용 검색기입니다.  
3) 작은 예시(이번 작업 맥락): 실제 키 모양(`sk-...`, `ghp_...`)이 들어갔는지 확인합니다.  
4) 자주 하는 오해 1개: 형식이 다른 비밀값은 놓칠 수 있어 단독 검사로 끝내면 안 됩니다.  
5) 이해 확인 질문 1개: "특정 형식 탐지"는 강력하지만 보조 수단이라는 점 괜찮으실까요?  

#### Step E-3. 최종 판단 규칙

1. 위험 패턴 1개라도 나오면 릴리즈 중단
2. 값 마스킹/삭제 후 같은 명령 재실행
3. 재검사에서 위험 결과가 없어야 다음 Step(F)로 진행

### Step F. 커밋 만들기

```bash
git add main.js manifest.json versions.json styles.css README.md README.ko.md
```

[명령어 설명]  
명령: `git add main.js manifest.json versions.json styles.css README.md README.ko.md`  
1) 한 줄 정의: 커밋에 포함할 파일을 선택(스테이징)합니다.  
2) 쉬운 비유: 배송 박스에 넣을 물건만 골라 담는 작업입니다.  
3) 작은 예시(이번 작업 맥락): 버전/코드/문서 파일만 선택해 릴리즈 커밋을 만듭니다.  
4) 자주 하는 오해 1개: `git add .`를 습관적으로 쓰면 `.DS_Store` 같은 불필요 파일까지 들어갈 수 있습니다.  
5) 이해 확인 질문 1개: 초보 단계에서는 파일명을 명시해서 add 하는 편이 안전하다는 점 괜찮으실까요?  

```bash
git commit -m "chore: release 0.3.10"
```

[명령어 설명]  
명령: `git commit -m "chore: release 0.3.10"`  
1) 한 줄 정의: 스테이징된 파일을 하나의 변경 기록으로 저장합니다.  
2) 쉬운 비유: 박스 포장 후 출고 전표를 붙이는 단계입니다.  
3) 작은 예시(이번 작업 맥락): `release 0.3.10`이라는 의미를 남겨 나중에 추적이 쉬워집니다.  
4) 자주 하는 오해 1개: 커밋 메시지는 길게 써야 좋다고 오해하기 쉽지만, 짧고 명확하면 충분합니다.  
5) 이해 확인 질문 1개: 커밋 메시지는 "무엇을 했는지" 한 줄로 알아볼 수 있어야 한다는 점 이해되셨나요?  

### Step G. 태그 생성

```bash
git tag -a 0.3.10 -m "0.3.10"
```

[명령어 설명]  
명령: `git tag -a 0.3.10 -m "0.3.10"`  
1) 한 줄 정의: 현재 커밋에 릴리즈 버전 태그를 붙입니다.  
2) 쉬운 비유: 제품 상자에 공식 버전 라벨을 붙이는 과정입니다.  
3) 작은 예시(이번 작업 맥락): `0.3.10` 태그가 릴리즈 기준점이 됩니다.  
4) 자주 하는 오해 1개: 태그를 만들어도 원격 저장소에 자동 업로드되진 않습니다.  
5) 이해 확인 질문 1개: 태그 생성 후 push가 추가로 필요하다는 점 이해되셨나요?  

### Step H. 원격 저장소로 업로드

```bash
git push origin main
```

[명령어 설명]  
명령: `git push origin main`  
1) 한 줄 정의: 로컬 커밋을 GitHub의 `main` 브랜치로 올립니다.  
2) 쉬운 비유: 창고(로컬)에 있던 박스를 물류센터(원격)로 보내는 과정입니다.  
3) 작은 예시(이번 작업 맥락): 커밋한 릴리즈 준비 변경사항이 GitHub에 반영됩니다.  
4) 자주 하는 오해 1개: 태그도 같이 올라간다고 생각하기 쉽지만, 태그는 별도 push가 필요합니다.  
5) 이해 확인 질문 1개: 브랜치 push와 태그 push가 분리되어 있다는 점 괜찮으실까요?  

```bash
git push origin 0.3.10
```

[명령어 설명]  
명령: `git push origin 0.3.10`  
1) 한 줄 정의: 로컬에서 만든 `0.3.10` 태그를 원격으로 업로드합니다.  
2) 쉬운 비유: 버전 라벨 정보를 물류센터에도 등록하는 단계입니다.  
3) 작은 예시(이번 작업 맥락): GitHub Release 생성 시 `0.3.10` 태그를 선택할 수 있게 됩니다.  
4) 자주 하는 오해 1개: 브랜치 push에 태그가 포함된다고 오해하기 쉽습니다.  
5) 이해 확인 질문 1개: 릴리즈 태그를 따로 push 해야 릴리즈 화면에서 보인다는 점 이해되셨나요?  

### Step I. 태그가 올바른 커밋을 가리키는지 확인

```bash
git show --name-only 0.3.10
```

[명령어 설명]  
명령: `git show --name-only 0.3.10`  
1) 한 줄 정의: 해당 태그가 가리키는 커밋과 포함 파일을 확인합니다.  
2) 쉬운 비유: 라벨이 붙은 상자를 열어 내용물이 맞는지 검수하는 단계입니다.  
3) 작은 예시(이번 작업 맥락): 릴리즈에 들어갈 파일들이 정확한지 마지막 확인이 가능합니다.  
4) 자주 하는 오해 1개: 태그 이름만 맞으면 된다고 생각하기 쉽지만, 가리키는 커밋이 중요합니다.  
5) 이해 확인 질문 1개: "태그 이름"보다 "태그가 가리키는 커밋" 검증이 핵심이라는 점 이해되셨나요?  

## 3) GitHub Release 페이지에서 해야 할 일

1. GitHub 저장소 열기
2. `Releases` -> `Draft a new release`
3. Tag 선택: `0.3.10`
4. 제목/설명 입력
5. Assets 업로드(필수 4개):
   - `manifest.json`
   - `main.js`
   - `styles.css`
   - `versions.json`
6. Publish release

업로드 범위 한 줄 요약:
- GitHub 릴리즈로 업로드되는 파일은 `manifest.json`, `main.js`, `styles.css`, `versions.json` 4개입니다.

## 4) 자주 하는 실수와 해결

### 실수 1) `versions.json` 업데이트를 빼먹음
- 증상: 설치/업데이트에서 버전 인식 문제 발생
- 해결: 새 버전을 `versions.json`에 추가 후 다시 커밋/태그

### 실수 2) 태그를 `v0.3.10`으로 만들고 manifest는 `0.3.10`인 경우
- 증상: 버전 일관성 혼란
- 해결: 프로젝트 규칙 하나로 통일 (권장: `0.3.10`)

### 실수 3) `.DS_Store` 같은 파일이 커밋에 들어감
- 해결 명령:

```bash
git restore --staged .DS_Store
```

[명령어 설명]  
명령: `git restore --staged .DS_Store`  
1) 한 줄 정의: 스테이징된 `.DS_Store`를 커밋 대상에서 제외합니다.  
2) 쉬운 비유: 포장 박스에 잘못 담긴 물건 하나만 다시 빼는 동작입니다.  
3) 작은 예시(이번 작업 맥락): `git add .`를 썼을 때 실수로 들어간 파일을 제거합니다.  
4) 자주 하는 오해 1개: 파일 자체가 삭제된다고 오해하기 쉽지만, 스테이징에서만 빠집니다.  
5) 이해 확인 질문 1개: 이 명령은 "커밋 대상에서 제외"이지 "파일 삭제"가 아니라는 점 이해되셨나요?  

## 5) 10분 체크리스트 (짧은 버전)

1. `git status --short` 확인
2. `node --check main.js` 통과
3. `manifest.json` 버전 올리기
4. `versions.json` 새 버전 추가
5. 민감정보 검색
6. `git add ...`
7. `git commit -m "chore: release X.Y.Z"`
8. `git tag -a X.Y.Z -m "X.Y.Z"`
9. `git push origin main`
10. `git push origin X.Y.Z`
11. GitHub Release에서 4개 파일 업로드
